'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var React__default = _interopDefault(React);
var antd = require('antd');
var Papa = _interopDefault(require('papaparse'));
var difference = _interopDefault(require('lodash/difference'));
var union = _interopDefault(require('lodash/union'));
var get = _interopDefault(require('lodash/get'));
var set = _interopDefault(require('lodash/set'));
var debounceFn = _interopDefault(require('lodash/debounce'));
var Fuse = _interopDefault(require('fuse.js'));

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it;

  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      return function () {
        if (i >= o.length) return {
          done: true
        };
        return {
          done: false,
          value: o[i++]
        };
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  it = o[Symbol.iterator]();
  return it.next.bind(it);
}

var getFieldsFromColumns = function getFieldsFromColumns(columns) {
  var fields = {};
  columns == null ? void 0 : columns.forEach(function (column) {
    var _ref;

    var title = column.title,
        key = column.key,
        dataIndex = column.dataIndex;
    var fieldName = (_ref = Array.isArray(dataIndex) ? dataIndex.join(".") : dataIndex) != null ? _ref : key;

    if (fieldName) {
      set(fields, fieldName, title);
    }
  });
  return fields;
};

var cleanupDataSource = function cleanupDataSource(dataSource, exportFieldNames, selectedFields) {
  if (!dataSource || dataSource.length === 0) {
    return {
      data: [],
      fields: []
    };
  }

  var newData = [].concat(dataSource);
  var fields = selectedFields.map(function (fieldName) {
    var fieldValue = get(exportFieldNames, fieldName);

    if (typeof fieldValue === "string") {
      return fieldValue;
    }

    return fieldValue.header || "";
  });
  var data = newData.map(function (record, rowIndex) {
    return selectedFields.map(function (fieldName) {
      var fieldValue = get(exportFieldNames, fieldName);
      var recordValue = get(record, fieldName);

      if (typeof fieldValue === "string") {
        return recordValue;
      }

      return (fieldValue == null ? void 0 : fieldValue.formatter(recordValue, record, rowIndex)) || null;
    });
  });
  return [fields].concat(data);
};

var ExportTableButton = function ExportTableButton(props) {
  var _props$children;

  var _props$dataSource = props.dataSource,
      dataSource = _props$dataSource === void 0 ? [] : _props$dataSource,
      fileName = props.fileName,
      fields = props.fields,
      disabled = props.disabled,
      btnProps = props.btnProps,
      _props$columns = props.columns,
      columns = _props$columns === void 0 ? [] : _props$columns,
      _props$showColumnPick = props.showColumnPicker,
      showColumnPicker = _props$showColumnPick === void 0 ? false : _props$showColumnPick;

  var _React$useState = React__default.useState(false),
      showModal = _React$useState[0],
      setShowModal = _React$useState[1];

  var fieldsOrColumns = fields != null ? fields : getFieldsFromColumns(columns);

  var _React$useState2 = React__default.useState(function () {
    if (fields) {
      return Object.keys(fields);
    } else if (columns) {
      return Object.keys(getFieldsFromColumns(columns));
    }

    return [];
  }),
      selectedFields = _React$useState2[0],
      setSelectedFields = _React$useState2[1];

  React.useEffect(function () {
    if (fields) {
      setSelectedFields(Object.keys(fields));
    } else if (columns) {
      setSelectedFields(Object.keys(getFieldsFromColumns(columns)));
    }
  }, [fields, columns]);
  var handleDownloadCSV = React__default.useCallback(function () {
    if (!dataSource) {
      return;
    }

    var selectedFieldsInOriginalOrder = Object.keys(fieldsOrColumns).filter(function (name) {
      return selectedFields.indexOf(name) > -1;
    });
    var data = cleanupDataSource(dataSource, fieldsOrColumns, selectedFieldsInOriginalOrder);
    var csv = Papa.unparse(data, {
      greedy: true,
      header: false
    });
    var blob = new Blob([csv]);
    var a = window.document.createElement("a");
    a.href = window.URL.createObjectURL(blob);
    a.download = (fileName || "table") + ".csv";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    setShowModal(false);
  }, [dataSource, fieldsOrColumns, selectedFields, fileName]);
  var handleCheckboxChange = React__default.useCallback(function (key, checked) {
    var newSelectedFields = [].concat(selectedFields);

    if (checked) {
      newSelectedFields = union(newSelectedFields, [key]);
    } else {
      newSelectedFields = difference(newSelectedFields, [key]);
    }

    setSelectedFields(newSelectedFields);
  }, [selectedFields]);
  return React__default.createElement(React.Fragment, null, React__default.createElement(antd.Button, Object.assign({
    onClick: function onClick() {
      return showColumnPicker ? setShowModal(true) : handleDownloadCSV();
    },
    disabled: disabled
  }, btnProps), (_props$children = props.children) != null ? _props$children : "Export to CSV"), showColumnPicker ? React__default.createElement(antd.Modal, {
    visible: showModal,
    onOk: function onOk() {
      return handleDownloadCSV();
    },
    onCancel: function onCancel() {
      return setShowModal(false);
    },
    width: 400,
    okButtonProps: {
      disabled: selectedFields.length < 1,
      title: selectedFields.length < 1 ? "Please select at least one column." : null
    },
    okText: "Export",
    title: "Select columns to export"
  }, React__default.createElement("div", {
    className: "d-flex flex-column align-start"
  }, Object.entries(fieldsOrColumns).map(function (_ref2) {
    var _value$header;

    var key = _ref2[0],
        value = _ref2[1];
    return React__default.createElement(antd.Checkbox, {
      key: key,
      style: {
        padding: 0,
        margin: 0
      },
      defaultChecked: true,
      checked: selectedFields.indexOf(key) > -1,
      onChange: function onChange(e) {
        return handleCheckboxChange(key, e.target.checked);
      }
    }, typeof value === "string" ? value : (_value$header = value == null ? void 0 : value.header) != null ? _value$header : "");
  }))) : null);
};

var getGroupedColumnKeysFromChildren = function getGroupedColumnKeysFromChildren(column, keys) {
  if (keys === void 0) {
    keys = [];
  }

  for (var _iterator = _createForOfIteratorHelperLoose(column.children), _step; !(_step = _iterator()).done;) {
    var child = _step.value;

    if (child.children && Array.isArray(child.children)) {
      // If child has children, recurse
      keys = getGroupedColumnKeysFromChildren(child, keys);
    } else {
      if (!child.dataIndex) {
        continue;
      }

      if (Array.isArray(child.dataIndex)) {
        keys = [].concat(keys, [child.dataIndex.join(".")]);
        continue;
      }

      keys = [].concat(keys, [child.dataIndex]);
    }
  }

  return keys;
};

var createDefaultFuseKeys = function createDefaultFuseKeys(dataSource, columns) {
  var firstRecord = dataSource == null ? void 0 : dataSource[0];
  var keys = columns.map(function (column) {
    var dataIndex = column.dataIndex,
        children = column.children; // check if grouped column

    if (children && Array.isArray(children)) {
      var _keys = getGroupedColumnKeysFromChildren(column, []);

      return _keys == null ? void 0 : _keys.flat();
    } // ant table allows nested objects with array of strings as dataIndex


    if (Array.isArray(dataIndex)) {
      return dataIndex.join(".");
    } // If in actual dataIndex the record is object literal but column specified as string, throw error.
    // Even though it's something you shouldn't do based on ant table's API, since users will see fuse.js `value.trim is not a function error` I'm throwing error.


    if (firstRecord && Object.prototype.toString.call(firstRecord[dataIndex]) === "[object Object]" && typeof dataIndex === "string") {
      throw new Error("'" + dataIndex + "' is an object in dataSource. But dataIndex is given as string. If it is an object, use array of strings as dataIndex.");
    }

    return dataIndex;
  }).filter(function (dataIndex) {
    return !!dataIndex;
  }).flat(10).filter(function (dataIndex) {
    return typeof dataIndex === "string";
  }); // after flattening max depth 10, if there are still arrays, ignore

  return keys;
};

var SearchTableInput = function SearchTableInput(_ref) {
  var _ref$searchFunction = _ref.searchFunction,
      searchFunction = _ref$searchFunction === void 0 ? null : _ref$searchFunction,
      dataSource = _ref.dataSource,
      setDataSource = _ref.setDataSource,
      _ref$debounce = _ref.debounce,
      debounce = _ref$debounce === void 0 ? true : _ref$debounce,
      _ref$inputProps = _ref.inputProps,
      inputProps = _ref$inputProps === void 0 ? {
    placeholder: "Search..."
  } : _ref$inputProps,
      _ref$fuzzySearch = _ref.fuzzySearch,
      fuzzySearch = _ref$fuzzySearch === void 0 ? false : _ref$fuzzySearch,
      columns = _ref.columns,
      fuseProps = _ref.fuseProps;

  var _useState = React.useState(""),
      query = _useState[0],
      setQuery = _useState[1];

  var allData = React.useRef();
  var fuse = React.useRef();

  var _fuseProps = React__default.useMemo(function () {
    return _extends({
      keys: createDefaultFuseKeys(dataSource, columns),
      threshold: fuzzySearch ? 0.6 : 0
    }, fuseProps);
  }, [fuseProps, dataSource, columns, fuzzySearch]);

  var searchTable = function searchTable(_dataSource, searchTerm) {
    if (searchTerm === void 0) {
      searchTerm = "";
    }

    if (searchTerm === "" || !fuse || !fuse.current) {
      return allData.current;
    }

    var newResults = fuse.current.search(searchTerm).map(function (res) {
      return res.item;
    });
    return newResults;
  };

  var searchTableDebounced = React__default.useCallback(debounceFn(function (dataSource, searchTerm, searchFn) {
    var results = searchFn == null ? void 0 : searchFn(dataSource, searchTerm);
    setDataSource(results);
  }, 100, {
    leading: false,
    trailing: true
  }), []);

  var handleInputChange = function handleInputChange(e) {
    var value = e.target.value;
    setQuery(value);

    if (debounce) {
      searchTableDebounced(dataSource, value, searchFunction != null ? searchFunction : searchTable);
    } else {
      var _searchFunction;

      var results = (_searchFunction = searchFunction == null ? void 0 : searchFunction(dataSource, value)) != null ? _searchFunction : searchTable(dataSource, value);
      setDataSource(results);
    }
  };

  React.useEffect(function () {
    if (!dataSource) {
      return;
    }

    allData.current = [].concat(dataSource);
    fuse.current = new Fuse(dataSource, _fuseProps);
  }, [dataSource, _fuseProps]);
  React.useEffect(function () {
    // If dataSource updates dynamically (for example, swr or react-query mutates) and the input box is not empty,
    // It should keep the new dataSource filtered if there is a value in input box
    if (!dataSource || !query) {
      return;
    }

    if (debounce) {
      searchTableDebounced(dataSource, query, searchFunction != null ? searchFunction : searchTable);
    } else {
      var _searchFunction2;

      var results = (_searchFunction2 = searchFunction == null ? void 0 : searchFunction(dataSource, query)) != null ? _searchFunction2 : searchTable(dataSource, query);
      setDataSource(results);
    }
  }, [query, dataSource, searchTableDebounced, searchFunction, setDataSource, debounce]);
  return React__default.createElement(antd.Input, Object.assign({
    value: query,
    onChange: handleInputChange,
    placeholder: "Search...",
    allowClear: true
  }, inputProps));
};

function useMountedState() {
  var ref = React.useRef(false);
  var state = React.useCallback(function () {
    return ref.current;
  }, []);
  React.useEffect(function () {
    ref.current = true;
    return function () {
      ref.current = false;
    };
  });
  return state;
}

var Table = function Table(_ref) {
  var _searchableProps$inpu;

  var _ref$exportable = _ref.exportable,
      exportable = _ref$exportable === void 0 ? false : _ref$exportable,
      exportableProps = _ref.exportableProps,
      _ref$searchable = _ref.searchable,
      searchable = _ref$searchable === void 0 ? false : _ref$searchable,
      searchableProps = _ref.searchableProps,
      dataSource = _ref.dataSource,
      columns = _ref.columns,
      otherProps = _objectWithoutPropertiesLoose(_ref, ["exportable", "exportableProps", "searchable", "searchableProps", "dataSource", "columns"]);

  var isMounted = useMountedState();
  var isExportable = exportable || exportableProps;
  var isSearchable = searchable || searchableProps;

  var _useState = React.useState(dataSource),
      searchDataSource = _useState[0],
      setSearchDataSource = _useState[1];

  React.useEffect(function () {
    if (isSearchable && isMounted()) {
      setSearchDataSource(dataSource);
    }
  }, [isSearchable, dataSource, isMounted]);
  return React__default.createElement("div", null, React__default.createElement("div", {
    style: {
      display: "flex",
      justifyContent: "space-between",
      marginBottom: 10
    }
  }, isExportable ? React__default.createElement(ExportTableButton, Object.assign({
    dataSource: dataSource,
    columns: columns
  }, exportableProps)) : null, isSearchable ? React__default.createElement(SearchTableInput, Object.assign({
    columns: columns,
    dataSource: dataSource,
    setDataSource: setSearchDataSource
  }, searchableProps, {
    inputProps: _extends({
      style: _extends({
        width: isExportable ? "60%" : "100%"
      }, searchableProps == null ? void 0 : (_searchableProps$inpu = searchableProps.inputProps) == null ? void 0 : _searchableProps$inpu.style)
    }, searchableProps == null ? void 0 : searchableProps.inputProps)
  })) : null), React__default.createElement(antd.Table, Object.assign({
    dataSource: isSearchable ? searchDataSource : dataSource,
    columns: columns
  }, otherProps)));
};

exports.ExportTableButton = ExportTableButton;
exports.SearchTableInput = SearchTableInput;
exports.Table = Table;
//# sourceMappingURL=ant-table-extensions.cjs.development.js.map
